---
title: "Comparing CLARITY, Omnibus Embedding and UASE"
author: "Rachel Wood"
date: "2023-03-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1234)
```

This document's goals are three-fold:

- Looking at how well different methods perform in identifying changes in the structure of data.
- Finding the way UASE embeddings change with scaling and mixing changes to the underlying generating tree structure.
- Identify a performance metric with which we can compare these different methods

# Data generation

We use the `ClaritySim` package to create the `original' data generated according to some tree structure, which we will then manipulate to test the different methods:

```{r}
library(ClaritySim)
n=100 
k=10
original <- simulateCoalescent(n,k,
                         sigma0=0.0001,
                         Amodel="uniform",
                         alpha=0,
                         minedge=0.1) # Simlulate 100 objects in a 10 dimensional latent space
plot(original$tree)
```

We can now manipulate the data in a series of ways.



## Tree Scaling

```{r}
scaled <- transformCoalescent(original)
plot(scaled$tree)
```

## Mixture

```{r, eval=FALSE}
mixed <- mixCoalescent(original, fraction = 1)
mixture <- mixed$edges

library(ape)
library(glottoTrees)

plot(mixed$tree)
edges(mixture[2], mixture[1], arrows = 1)

```

## Swapping node

```{r}
tree <- original$tree

newtree <- tree
newtree$tip.label <-c("t2", "t1", "t3", "t4", "t5", "t6", "t7", "t8", "t9", "t10")

swapped <- simulateCoalescent(n,k,
                         sigma0=0.0001,
                         Amodel="uniform",
                         alpha=0,
                         minedge=0.1,
                         tree = newtree) 
```

# UASE

We first include our R functions for UASE embedding
```{r}

UASE <- function(Y, A, K, d = 2){
  svd <- svd(Y)
  population <- A %*% colnames(A)
  
  
  U <- svd$u %*% diag(sqrt(svd$d))
  
  t <- rep(1:K, each = nrow(A))
  index <- rep(1:nrow(A),K)
  V <- svd$v %*% diag(sqrt(svd$d))
  V <- V[,1:d]
  right <- as.data.frame(cbind(V,as.factor(t), 
                               as.factor(population), 
                               as.factor(index)))
  
  
}

UASE_right <- function(A,d = 2, K){
  svd <- svd(A)
  Y <- svd$v %*% diag(sqrt(svd$d))
  Y <- Y[,1:d]
  t <- rep(1:K, each = nrow(A))
  data <- rep(1:nrow(A),K)
  
  Y <- as.data.frame(cbind(Y,as.factor(t), as.factor(data)))
  colnames(Y) <- c(1:d,"discipline", "data_point")
  return(Y)
}

UASE_left <- function(A,d = 2, K){
  svd <- svd(A)
  Y <- svd$u %*% diag(sqrt(svd$d))
  Y <- Y[,1:d]
  Y <- as.data.frame(Y)
  colnames(Y) <- c(1:d)
  return(Y)
}
```



